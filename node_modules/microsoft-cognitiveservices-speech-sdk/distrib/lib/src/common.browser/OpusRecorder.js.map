{"version":3,"sources":["../../src/common.browser/OpusRecorder.ts"],"names":[],"mappings":";AAAA,4DAA4D;AAC5D,kCAAkC;;AAQlC;IAII,sBAAY,OAAqD;QAAjE,iBAEC;QAEM,WAAM,GAAG,UAAC,OAAqB,EAAE,WAAwB,EAAE,YAAiC;YAC/F,IAAM,aAAa,GAAQ,IAAI,aAAa,CAAC,WAAW,EAAE,KAAI,CAAC,wBAAwB,CAAC,CAAC;YACzF,IAAM,SAAS,GAAG,GAAG,CAAC,CAAC,2GAA2G;YAClI,aAAa,CAAC,eAAe,GAAG,UAAC,kBAAuB;gBACpD,IAAI,YAAY,EAAE;oBACd,IAAM,QAAM,GAAG,IAAI,UAAU,EAAE,CAAC;oBAChC,QAAM,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;oBAClD,QAAM,CAAC,SAAS,GAAG,UAAC,KAAoB;wBACpC,YAAY,CAAC,KAAK,CAAC,QAAM,CAAC,MAAqB,CAAC,CAAC;oBACrD,CAAC,CAAC;iBACL;YACL,CAAC,CAAC;YAEF,KAAI,CAAC,kBAAkB,GAAG;gBACtB,QAAQ,EAAE,aAAa;gBACvB,MAAM,EAAE,WAAW;aACtB,CAAC;YACF,aAAa,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACnC,CAAC,CAAA;QAEM,0BAAqB,GAAG,UAAC,OAAqB;YACjD,IAAI,KAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,KAAK,KAAK,UAAU,EAAE;gBACvD,KAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;aAC3C;YACD,KAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,UAAC,KAAU,IAAK,OAAA,KAAK,CAAC,IAAI,EAAE,EAAZ,CAAY,CAAC,CAAC;QACrF,CAAC,CAAA;QA5BG,IAAI,CAAC,wBAAwB,GAAG,OAAO,CAAC;IAC5C,CAAC;IA4BL,mBAAC;AAAD,CAlCA,AAkCC,IAAA;AAlCY,oCAAY;AAyCzB;;;;;;;;GAQG","file":"OpusRecorder.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { Stream } from \"../common/Exports\";\r\nimport { IRecorder } from \"./IRecorder\";\r\n\r\n// getting around the build error for MediaRecorder as Typescript does not have a definition for this one.\r\ndeclare var MediaRecorder: any;\r\n\r\nexport class OpusRecorder implements IRecorder {\r\n    private privMediaResources: IMediaResources;\r\n    private privMediaRecorderOptions: any;\r\n\r\n    constructor(options?: { mimeType: string, bitsPerSecond: number }) {\r\n        this.privMediaRecorderOptions = options;\r\n    }\r\n\r\n    public record = (context: AudioContext, mediaStream: MediaStream, outputStream: Stream<ArrayBuffer>): void => {\r\n        const mediaRecorder: any = new MediaRecorder(mediaStream, this.privMediaRecorderOptions);\r\n        const timeslice = 100; // this is in ms - 100 ensures that the chunk doesn't exceed the max size of chunk allowed in WS connection\r\n        mediaRecorder.ondataavailable = (dataAvailableEvent: any) => {\r\n            if (outputStream) {\r\n                const reader = new FileReader();\r\n                reader.readAsArrayBuffer(dataAvailableEvent.data);\r\n                reader.onloadend = (event: ProgressEvent) => {\r\n                    outputStream.write(reader.result as ArrayBuffer);\r\n                };\r\n            }\r\n        };\r\n\r\n        this.privMediaResources = {\r\n            recorder: mediaRecorder,\r\n            stream: mediaStream,\r\n        };\r\n        mediaRecorder.start(timeslice);\r\n    }\r\n\r\n    public releaseMediaResources = (context: AudioContext): void => {\r\n        if (this.privMediaResources.recorder.state !== \"inactive\") {\r\n            this.privMediaResources.recorder.stop();\r\n        }\r\n        this.privMediaResources.stream.getTracks().forEach((track: any) => track.stop());\r\n    }\r\n}\r\n\r\ninterface IMediaResources {\r\n    stream: MediaStream;\r\n    recorder: any;\r\n}\r\n\r\n/* Declaring this inline to avoid compiler warnings\r\ndeclare class MediaRecorder {\r\n    constructor(mediaStream: MediaStream, options: any);\r\n\r\n    public state: string;\r\n\r\n    public ondataavailable(dataAvailableEvent: any): void;\r\n    public stop(): void;\r\n}*/\r\n"]}